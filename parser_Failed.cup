/*
	show the import
*/
import java.io.*;
import java.util.*;
import java_cup.runtime.*;

terminal VOID, CHAR, INT, STRUCT, UNION, IF, ELSE, WHILE, FOR, CONTINUE, BREAK, RETURN, SIZEOF;

terminal LPA, RPA, SEMI, COMMA, EVA, LCU, RCU, LSQ, RSQ, MUL, OR, XOR, AND, LT, GT, ADD, SUB, DIV, MOD, COM, NOT, DOT;

terminal OR_L, AND_L, EQ, NE, LE, GE, SHL, SHR, INC, DEC, PTR;

terminal MUL_ASSIGN, DIV_ASSIGN, MOD_ASSIGN, ADD_ASSIGN, SUB_ASSIGN, SHL_ASSIGN, SHR_ASSIGN, AND_ASSIGN, XOR_ASSIGN, OR_ASSIGN;

terminal String ID, CONSTINT, CONSTCHAR, CONSTSTR;

non terminal Node root, declaration, function_definition, parameters, declarators, init_declarators, init_declarator, initializer, type_specifier, struct_or_union, plain_declaration, declarator, plain_declarator;

non terminal Node statement, expression_statement, compound_statement, iteration_statement, jump_statement;

/*select_statement*/
non terminal Node if_then_statement, if_then_else_statement, if_then_else_statement_no_short_if, statement_no_short_if, further_statement;

non terminal Node expression, assignment_expression, assignment_operator, constant_expression, logical_or_expression, logical_and_expression;

non terminal Node inclusive_or_expression, exclusive_or_expression, and_expression, equality_expression, equality_operator, relational_expression;

non terminal Node relational_operator, shift_expression, shift_operator, additive_expression, additive_operator, multiplicative_expression;

non terminal Node multiplicative_operator, cast_expression, type_name, unary_expression, unary_operator, postfix_expression, postfix, arguments;

non terminal Node primary_expression;
non terminal Node t_initializer, t_type_specifier, t_declarator, t_declaration, t_statement, identifier;

root ::= 
	declaration:l {: RESULT = new Node(ROOT, "root",  l); :}
	| function_definition:l {: RESULT = new Node(ROOT, "root", l) :}
	| root:l declaration:r {: l.merge(r); RESULT = l; :}
	| root:l function_definition:r {:l.merge(r); RESULT = l; :}
	;

declaration ::=
	type_specifier:l SEMI {: RESULT = new Node(DECLARATION, "declaration", l); :}
	| type_specifier:l init_declarators:r SEMI {: RESULT = new Node(DECLARATION, "declaration", l, r); :}
	;

function_definition ::=
	type_specifier:a plain_declarator:b LPA RPA compound_statement:d {: RESULT = new Node(FUNCTION_DEFINITION, "function_definition", a, b, d) :}
	| type_specifier:a plain_declarator:b LPA parameters:c RPA compound_statement:d {: RESULT = new Node(FUNCTION_DEFINITION, "function_definition", a, b, c, d); :}
	;

parameters ::=
	plain_declaration:l {: RESULT =  new Node(PARAMETERS, "parameters", l) :}
	| parameters:t COMMA plain_declaration:l {: t.Merge(l); RESULT = t; :}
	;

declarators ::=
	declarator:l {: RESULT = new Node(DECLARATORS, "declarators", l) :}
	| declarators:t COMMA declarator:l {: t.Merge(l); RESULT = t; :}
	;

init_declarators ::=
	init_declarator:l {: RESULT = new Node(INIT_DECLARATORS, "init_declarators", l) :}
	| init_declarators:t COMMA init_declarator:l {: t.Merge(l); RESULT = t; :}
	;

init_declarator ::=
	declarator:l {: RESULT = new Node(INIT_DECLARATOR, "init_declarator", l); :}
	| declarator:a EVA initializer:b {: RESULT = new Node(INIT_DECLARATOR, "init_declarator = ", a, b); :}
	;
	
initializer ::=
	assignment_expression
	| LCU t_initializer:c RCU {: RESULT = new Node(INITIALIZER, "initializer {}", c) :}
	;

t_initializer ::=
	initializer:a {: RESULT = new Node(INITIALIZER, "initializers", a); :}
	| t_initializer:b COMMA initializer:a {: b.Merge(a); RESULT = b; :} 
	;

type_specifier ::=
	VOID {: RESULT = new Node(KEYWORDS, "void"); :}
	| CHAR {: RESULT = new Node(KEYWORDS, "char"); :}
	| INT {: RESULT = new Node(KEYWORDS, "int"); :}
	| struct_or_union:b LCU t_type_specifier:a RCU {: RESULT = new Node(TYPE_SPECIFIER, "type_specifier {}",b, a); ):}
	| struct_or_union:b ID:s LCU t_type_specifier:a RCU {: RESULT = new Node(TYPE_SPECIFIER, "type_specifier identifier {}", b, s, a); :}
	| struct_or_union:b ID:s {: RESULT = new NOde(TYPE_SPECIFIER, "type_specifier", b, s); :}
	;

t_type_specifier ::=
	type_specifier:a declarators:b SEMI {: RESULT = new Node(TYPE_SPECIFIERS, "type_specifiers", a, b); :}
	| t_type_specifier:t type_specifier:a declarators:b SEMI
		{: t.merge(a); t.merge(b); RESULT = t; :}
	;

struct_or_union ::=
	STRUCT {: RESULT = new Node(KEYWORDS, "struct"); :}
	| UNION {: RESULT = new Node(KEYWORDS, "union"); :}
	;

plain_declaration ::=
	type_specifier:a declarator:b {: RESULT = new Node(PLAIN_DECLARATION, "plain_declaration", a, b); :}
	;

declarator ::=
	plain_declarator:a LPA RPA {: RESULT = new Node(DECLARATOR, "declarator ()", a); :}
	| plain_declarator:a LPA parameters:b RPA	
		{: RESULT = new Node(DECLARATOR, "declarator ()", a, b); :}
	| plain_declarator:a {: RESULT = new Node(DECLARATOR, "declarator", a); :}
	| plain_declarator:a t_declarator:b {: RESULT = new Node(DECLARATOR, "declarator", a, b); :}
	;

t_declarator ::=
	LSQ constant_expression:a RSQ {: RESULT = new Node(DECLARATOR, "declarators []", a); :}
	| t_declarator:b LSQ constant_expression:a RSQ {: RESULT = new Node(DECLARATOR, "declarators []", b, a); :}
	;

plain_declarator ::=
	identifier
	| MUL plain_declarator:a {: RESULT = new Node(PLAIN_DECLARATOR, "plain_declarator *", a); :}
	;

/*---type ending----*/

statement ::=
	further_statement
	| if_then_statement
	| if_then_else_statement
	;

statement_no_short_if ::=
	further_statement
	| if_then_else_statement_no_short_if
	;

further_statement ::=
	expression_statement
	| compound_statement
	| iteration_statement
	| jump_statement
	;

expression_statement ::=
	SEMI {: RESULT = new Node(EXPRESSION_STATEMENT, "expression_statement"); :}
	| expression:a SEMI {: RESULT = a; :}
	;

compound_statement ::=
	LCU RCU {: RESULT = new Node(COMPOUND_STATEMENT, "compound_statement {}"); :}
	| LCU t_declaration:a RCU {: RESULT = new Node(COMPOUND_STATEMENT, "compound_statement {}", a); :}
	| LCU t_statement:a RCU {: RESULT = new Node(COMPOUND_STATEMENT, "compound_statement {}", a); :}
	| LCU t_declaration:a t_statement:b RCU {: RESULT = new Node(COMPOUND_STATEMENT, "compound_statement {}", a, b); :}
	;

t_declaration ::=
	declaration:a {: RESULT = new Node(DECLARATION, "declarations", a) :}
	| t_declaration:a declaration:b {: a.Merge(b); RESULT = a; :}
	;

t_statement ::=
	statement:a{: RESULT = new Node(STATEMENT, "statement", a); :}
	| t_statement:a statement:b {: a.Merge(b); RESULT = a; :}
	;

/*
selection_statement ::=
	IF LPA expression:a RPA statement:b {: RESULT = new Node (SELECTION_STATEMENT, "selection_statement if", a, b); :}
	| IF LPA expression:a RPA statement:b ELSE statement:c {: RESULT = new Node (SELECTION_STATEMENT, "selection_statement if else", a, b, c); :}
	;
*/
if_then_statement ::=
	IF LPA expression:a RPA statement:b {: RESULT = new Node (SELECTION_STATEMENT, "selection_statement if", a, b); :}
	;
if_then_else_statement ::=
	IF LPA expression:a RPA statement_no_short_if:b ELSE statement:c {: RESULT = new Node (SELECTION_STATEMENT, "selection_statement if else", a, b, c); :}
	;
if_then_else_statement_no_short_if ::=
	IF LPA expression:a RPA statement_no_short_if:b ELSE statement_no_short_if:c {: RESULT = new Node (SELECTION_STATEMENT, "selection_statement if else", a, b, c); :}
	;
	
iteration_statement ::=
	WHILE LPA expression:a RPA statement:b {: RESULT = new Node(ITERATION_STATEMENT, "while()", a, b); :}
    | FOR LPA            SEMI            SEMI            RPA statement:a {:
        $$ = new Node(ITERATION_STATEMENT, "for(;;)", a);
    :}
    | FOR LPA            SEMI            SEMI expression:a RPA statement:b {:
        $$ = new Node(ITERATION_STATEMENT, "for(;;*)", a, b);
    :}
    | FOR LPA            SEMI expression:a SEMI            RPA statement:b {:
        $$ = new Node(ITERATION_STATEMENT, "for(;*;)", a, b);
    :}
    | FOR LPA            SEMI expression:a SEMI expression:b RPA statement:c {:
        $$ = new Node(ITERATION_STATEMENT, "for(;*;*)", a, b, c);
    :}
    | FOR LPA expression:a SEMI            SEMI            RPA statement:b {:
        $$ = new Node(ITERATION_STATEMENT, "for(*;;)", a, b);
    :}
    | FOR LPA expression:a SEMI            SEMI expression:b RPA statement:c {:
        $$ = new Node(ITERATION_STATEMENT, "for(*;;*)", a, b, c);
    :}
    | FOR LPA expression:a SEMI expression:b SEMI            RPA statement:c {:
        $$ = new Node(ITERATION_STATEMENT, "for(*;*;)", a, b, c);
    :}
    | FOR LPA expression:a SEMI expression:b SEMI expression:c RPA statement:d {:
        $$ = new Node(ITERATION_STATEMENT, "for(*;*;*)", a, b, c, d);
    :}
    ;
    
jump_statement ::=
	CONTINUE SEMI {: RESULT = new Node(JUMP_STATEMENT, "jump_statement", new Node(CONTINUE, "continue")); :}
	| BREAK SEMI {: RESULT = new Node(JUMP_STATEMENT, "jump_statement", new Node(BREAK, "break")); :}
	| RETURN SEMI {: RESULT = new Node(JUMP_STATEMENT, "jump_statement", new Node(RETURN, "return")); :}
	| RETURN expression:a SEMI {: RESULT = new Node(JUMP_STATEMENT, "jump_statement", new Node(RETURN, "return"), a); :}
	;
    
/*---------------------------------------*/


expression ::=
	  assignment_expression:a {: RESULT = new Node(EXPRESSION, "expression", a); :}
	  | expression:a COMMA assignment_expression:b {: RESULT = new Node(EXPRESSION, "expression", a, b); :}
	  ;

assignment_expression ::=
	logical_or_expression
	| unary_expression:a assignment_operator:b assignment_expression:c {: RESULT = new Node(ASSIGN_EXPRESSION, "assignment_expression", a, b, c); :}
	;

assignment_operator ::=
	EVA {: RESULT = new Node(OPERATOR, "="); :}
	| MUL_ASSIGN {: RESULT = new Node(OPERATOR, "*="); :}
	| DIV_ASSIGN {: RESULT = new Node(OPERATOR, "/="); :}
	| MOD_ASSIGN {: RESULT = new Node(OPERATOR, "%="); :} 
	| ADD_ASSIGN {: RESULT = new Node(OPERATOR, "+="); :}
	| SUB_ASSIGN {: RESULT = new Node(OPERATOR, "-="); :}
	| SHL_ASSIGN {: RESULT = new Node(OPERATOR, "<<="); :}
	| SHR_ASSIGN {: RESULT = new Node(OPERATOR, ">>="); :}
	| AND_ASSIGN {: RESULT = new Node(OPERATOR, "&="); :}
	| XOR_ASSIGN {: RESULT = new Node(OPERATOR, "^="); :}
	| OR_ASSIGN  {: RESULT = new Node(OPERATOR, "|="); :}
	;

constant_expression ::=
	logical_or_expression
	;

logical_or_expression ::=
	logical_and_expression
	| logical_or_expression:a OR_L logical_and_expression:c {: RESULT = new Node(LOGICAL_OR_ERPRESSION, "logical_or_expression ||", a, c); :}
	;

logical_and_expression ::=
	inclusive_or_expression
	| logical_and_expression:a AND_L inclusive_or_expression:c {: RESULT = new Node(LOGICAL_AND_ERPRESSION, "logical_and_expression &&", a, c); :}
	;
	
inclusive_or_expression ::=
	exclusive_or_expression
	| inclusive_or_expression:a OR exclusive_or_expression:c {: RESULT = new Node(INCLUSIVE_OR_ERPRESSION, "inclusive_or_expression or", a, c); :}
	;

exclusive_or_expression ::=
	and_expression
	| exclusive_or_expression:a XOR and_expression:c {: RESULT = new Node(EXCLUSIVE_OR_ERPRESSION, "exclusive_or_expression xor", a, c); :}
	;
	
and_expression ::=
	equality_expression
	| and_expression:a AND equality_expression:c {: RESULT = new Node(AND_ERPRESSION, "and_expression and", a, c); :}
	;
	
equality_expression ::=
	relational_expression
	| equality_expression:a equality_operator:b relational_expression:c {: RESULT = new Node(EQUALITY_ERPRESSION, "equality_expression", a, b, c); :}
	;
	
equality_operator ::=
	EQ {: RESULT = new Node(OPERATOR, "=="); :}
	| NE {: RESULT = new Node(OPERATOR, "!="); :}
	;

relational_expression ::=
	shift_expression
	| relational_expression:a relational_operator:b shift_expression:c {: RESULT = new Node(RELATIONAL_ERPRESSION, "relational_expression", a, b, c); :}
	;

relational_operator ::=
	LT {: RESULT = new Node(OPERATOR, "<"); :}
	| GT {: RESULT = new Node(OPERATOR, ">"); :}
	| LE {: RESULT = new Node(OPERATOR, "<="); :}
	| GE {: RESULT = new Node(OPERATOR, ">="); :}
	;

shift_expression ::=
	additive_expression
	| shift_expression:a shift_operator:b additive_expression:c {: RESULT = new Node(SHIFT_ERPRESSION, "shift_expression", a, b, c); :}
	;

shift_operator ::=
	SHL {: RESULT = new Node(OPERATOR, "<<"); :}
	| SHR {: RESULT = new Node(OPERATOR, ">>"); :}
	;
	
additive_expression ::=
	multiplicative_expression
	| additive_expression:a additive_operator:b multiplicative_expression:c {: RESULT = new Node(ADDITIVE_ERPRESSION, "additive_expression", a, b, c); :}
	;

additive_operator ::=
	ADD {: RESULT = new Node(OPERATOR, "+"); :}
	| SUB {: RESULT = new Node(OPERATOR, "-"); :}
	;

multiplicative_expression ::=
	cast_expression
	| multiplicative_expression:a multiplicative_operator:b cast_expression:c {: RESULT = new Node(MULTIPLICATIVE_ERPRESSION, "multiplicative_expression", a, b, c); :}
	;

multiplicative_operator ::=
	MUL {: RESULT = new Node(OPERATOR, "*"); :}
	| DIV {: RESULT = new Node(OPERATOR, "/"); :}
	| MOD {: RESULT = new Node(OPERATOR, "%"); :}
	;

cast_expression ::=
	unary_expression
	| LPA type_name:a RPA cast_expression:b {: RESULT = new Node(CAST_EXPRESSION, "cast_expression ()", a, b); :}
	;

type_name ::=
	type_specifier:a {: RESULT = new Node(TYPE_NAME, "type_name", a); :}
	| type_name MUL {: RESULT = new Node(TYPE_NAME, "type_name", new Node(OPERATOR, "*")); :}
	;

unary_expression ::=
	postfix_expression
	| INC unary_expression:a {: RESULT = new Node(UNARY_EXPRESSION, "unary_expression", new Node(OPERATOR, "++"), a); :}
	| DEC unary_expression:a {: RESULT = new Node(UNARY_EXPRESSION, "unary_expression", new Node(OPERATOR, "--"), a); :}
	| unary_operator:a cast_expression:b {: RESULT = new Node(UNARY_EXPRESSION, "unary_expression", a, b); :}
	| SIZEOF unary_expression:a {: RESULT = new Node(UNARY_EXPRESSION, "unary_expression", new Node(OPERATOR, "sizeof"), a); :}
	| SIZEOF LPA type_name:a RPA {: RESULT = new Node(UNARY_EXPRESSION, "unary_expression()", new Node(OPERATOR, "sizeof"), a); :}
	;

unary_operator ::=
	AND {: RESULT = new Node(UNARY_OPERATOR, "&"); :}
	| MUL {: RESULT = new Node(UNARY_OPERATOR, "*"); :}
	| ADD {: RESULT = new Node(UNARY_OPERATOR, "+"); :}
	| SUB {: RESULT = new Node(UNARY_OPERATOR, "-"); :}
	| COM {: RESULT = new Node(UNARY_OPERATOR, "~"); :}
	| NOT {: RESULT = new Node(UNARY_OPERATOR, "!"); :}
	;

postfix_expression ::=
	primary_expression
	| postfix_expression:a postfix:b {: RESULT = new Node(POSTFIX_EXPRESSION, "postfix_expression", a, b); :}
	;
	
postfix ::=
	LSQ expression:a RSQ {: RESULT = new Node(POSTFIX, "postfix []", a); :}
	| LPA RPA {: RESULT = new Node(POSTFIX, "postfix ()"); :}
	| LPA arguments:a RPA {: RESULT = new Node(POSTFIX, "postfix ()", a); :}
	| DOT identifier:a {: RESULT = new Node(POSTFIX, "postfix .", new Node(OPERATOR, ".")); :}
	| PTR identifier:a {: RESULT = new Node(POSTFIX, "postfix ->", new Node(OPERATOR, "->")); :}
	| INC  {: RESULT = new Node(POSTFIX, "postfix []", new Node(OPERATOR, "++")); :}
	| DEC  {: RESULT = new Node(POSTFIX, "postfix []", new NOde(OPERATOR, "--")); :}
	;

arguments ::=
	assignment_expression:a {: RESULT = create_node(ARGUMENTS, "arguments", a) :}
	| arguments:b COMMA assignment_expression:a {: b.Merge(a);RESULT = b;  :}
	;

primary_expression ::=
	  identifier
	| CONSTINT:l {: RESULT = new Node(INTEGER_CONSTANT, l); :}
	| CONSTCHAR:l {: RESULT = new Node(CHARACTER_CONSTANT, l); :}
	| CONSTSTR:l  {: RESULT = new Node(STRING_CONSTANT, l); :}
	| LPA expression:t RPA {: RESULT = new Node(PRIMARY_EXPRESSION, "primary_expression ()", t); :}
	;

identifier ::=
	ID:l				{: RESULT = new Identifier(l); :}
	;
	

